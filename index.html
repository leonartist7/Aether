<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Harmonic Void: Zenith (Solar Injection)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #050508; overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            user-select: none; touch-action: none;
        }

        /* LAYERS */
        #canvas-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; pointer-events: none; 
        }
        
        #main-canvas { width: 100%; height: 100%; display: block; }

        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; 
        }

        /* START SCREEN */
        #splash-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
            z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        #splash-screen.hidden { opacity: 0; pointer-events: none; }
        .ignite-btn {
            font-size: 30px; letter-spacing: 5px; color: #fff; background: transparent; border: none;
            padding: 20px 60px; cursor: pointer; text-transform: uppercase; 
            box-shadow: 0 0 40px rgba(255,255,255,0.1); transition: 0.3s;
            background: rgba(255,255,255,0.05); border-radius: 8px;
        }
        .ignite-btn:active { background: white; color: black; transform: scale(0.95); }

        /* INTERFACE */
        #mandala {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            width: 55vh; height: 55vh; max-width: 500px; max-height: 500px;
        }
        #sequencer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40%; height: 40%; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; z-index: 5;
        }
        #radar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; pointer-events: none;
        }
        #seq-sun {
            width: 65px; height: 65px; background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(4px);
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            /* No Border */
            color: rgba(255,255,255,0.7); font-weight: bold; font-size: 10px; text-align: center;
            cursor: pointer; z-index: 30; 
            box-shadow: 0 0 30px rgba(255,255,255,0.05); transition: transform 0.1s, box-shadow 0.2s, background 0.2s, color 0.2s;
        }
        #seq-sun.drag-hover { transform: scale(1.2); box-shadow: 0 0 50px white; background: rgba(255,255,255,0.3); color: white; }
        #seq-sun:active { transform: scale(0.9); background: rgba(255,255,255,0.25); box-shadow: 0 0 50px rgba(255,255,255,0.2); }
        
        .planet {
            position: absolute; width: 28px; height: 28px;
            background: rgba(40,40,50,0.5); border-radius: 50%; /* No Border */
            cursor: pointer; transition: 0.1s; z-index: 25; transform: translate(-50%, -50%);
        }
        .planet.active { background: rgba(255,255,255,0.9); box-shadow: 0 0 20px rgba(255,255,255,0.6); transform: translate(-50%, -50%) scale(1.2); }
        .planet.trigger { background: #ff0055; box-shadow: 0 0 40px #ff0055; transform: translate(-50%, -50%) scale(1.6); }

        .chord-orb {
            position: absolute; width: 75px; height: 75px; border-radius: 50%;
            background: rgba(30,30,40,0.3); backdrop-filter: blur(6px); /* No Border */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; transition: background 0.1s, box-shadow 0.1s; z-index: 20; transform: translate(-50%, -50%);
            /* Ensure it's above everything when dragging */
        }
        .chord-orb.dragging { z-index: 100; }
        .chord-orb.active { 
            background: var(--glow); color: white; 
            box-shadow: 0 0 80px var(--glow); text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .roman { font-size: 20px; font-weight: 700; pointer-events: none; opacity: 0.9; }
        .note-name { font-size: 10px; opacity: 0.6; pointer-events: none; }
        
        /* PIVOTS */
        .pivot-group { position: absolute; pointer-events: none; display: flex; gap: 8px; justify-content: center; transform: translate(-50%, -50%); z-index: 15; }
        .pivot-btn {
            pointer-events: auto; width: 35px; height: 35px; border-radius: 50%; 
            background: rgba(20,20,20,0.8); color: #aaa; font-size: 8px; 
            display: flex; justify-content: center; align-items: center; cursor: pointer; transition: 0.2s;
        }
        .pivot-btn:hover { background: white; color: black; transform: scale(1.1); }

        /* CONTROLS */
        #controls-deck {
            position: absolute; bottom: 0; width: 100%; height: 180px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%); 
            pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; padding-bottom: 20px; align-items: center;
        }
        .deck-row { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; pointer-events: auto; }

        /* BORDERLESS PADS */
        .pad-btn {
            width: 90px; height: 65px; border-radius: 12px;
            background: rgba(255,255,255,0.08); /* No Border */
            backdrop-filter: blur(5px); color: rgba(255,255,255,0.7);
            display: flex; justify-content: center; align-items: center; font-size: 16px; font-weight: bold; cursor: pointer; letter-spacing: 2px; transition: 0.2s; user-select: none;
            position: relative; overflow: visible; 
        }
        .pad-btn.active { background: rgba(255,255,255,0.9); color: black; box-shadow: 0 0 40px rgba(255,255,255,0.4); transform: scale(0.95); }
        
        /* CUSTOM LOCK COLORS */
        #btn-arp.locked { background: rgba(100, 255, 150, 0.7); color: white; box-shadow: 0 0 40px rgba(100, 255, 150, 0.5); }
        #btn-pulse.locked { background: rgba(100, 180, 255, 0.7); color: white; box-shadow: 0 0 40px rgba(100, 180, 255, 0.5); }
        
        /* MENU */
        .opt-menu {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; opacity: 0; pointer-events: none; transition: opacity 0.2s, transform 0.2s;
            background: rgba(10,10,10,0.9); padding: 8px; border-radius: 12px;
            z-index: 100; box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        .pad-btn.menu-open .opt-menu { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(0); }
        .opt-item {
            width: 45px; height: 45px; background: rgba(255,255,255,0.1); border-radius: 8px; 
            display: flex; justify-content: center; align-items: center; font-size: 10px; color: #aaa; text-transform: uppercase; transition: 0.2s;
        }
        .opt-item.selected { background: white; color: black; box-shadow: 0 0 15px white; }
        
        /* BORDERLESS INSTRUMENTS */
        .inst-btn {
            width: 45px; height: 45px; background: rgba(255,255,255,0.05); cursor: pointer; /* No Border */
            display: flex; justify-content: center; align-items: center; transition: 0.2s; border-radius: 6px;
        }
        .inst-btn.selected { box-shadow: 0 0 20px rgba(255, 204, 0, 0.4); background: rgba(255, 204, 0, 0.15); }
        .icon { width: 18px; height: 18px; background: rgba(255,255,255,0.4); }
        .inst-btn.selected .icon { opacity: 1; background: #ffcc00; }
        .i-tri { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); } .i-sq { } .i-cir { border-radius: 50%; }

        /* VOICING */
        #voicing-control {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%); height: 200px; width: 40px; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 6px; height: 150px; padding: 0 5px; background: rgba(255,255,255,0.1); border-radius: 4px; border: none;
        }
        .v-label { font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 1px; writing-mode: vertical-rl; transform: rotate(180deg); }

        /* SETTINGS */
        #settings-toggle { position: absolute; bottom: 30px; right: 30px; color: rgba(255,255,255,0.5); font-size: 28px; cursor: pointer; pointer-events: auto; z-index: 100; transition: 0.3s; }
        #settings-toggle:hover { color: white; transform: rotate(90deg); }
        #settings-panel {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 65%;
            background: rgba(10,10,15,0.98); z-index: 90; transform: translateY(110%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            padding: 30px; display: flex; flex-direction: column; gap: 15px; pointer-events: auto; border-top-left-radius: 20px; border-top-right-radius: 20px;
        }
        #settings-panel.open { transform: translateY(0); }
        .setting-row { display: flex; flex-direction: column; gap: 5px; }
        .setting-group { margin-top: 10px; border-top: 1px solid #333; padding-top: 15px; }
        label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        select, input[type=range]:not([orient=vertical]) { background: #222; color: white; border: none; padding: 10px; border-radius: 4px; outline: none; font-family: inherit; }
        #tuning-val { font-size: 14px; color: #ffcc00; font-weight: bold; text-align: right; margin-top: -5px; }
        .locked-label { position: absolute; bottom: -20px; font-size: 9px; color: white; font-weight: bold; opacity: 0; transition: opacity 0.2s; text-shadow: 0 0 5px rgba(0,0,0,0.8);}
        .pad-btn.locked .locked-label { opacity: 1; }
        
        .check-group { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .check-group input { width: auto; margin: 0; }
        
        .drag-line { stroke: white; stroke-width: 3px; stroke-linecap: round; opacity: 0.8; filter: drop-shadow(0 0 5px white); }
    </style>
</head>
<body>

    <div id="canvas-layer"><canvas id="main-canvas"></canvas></div>
    <svg id="svg-layer"><line id="drag-cable" x1="0" y1="0" x2="0" y2="0" class="drag-line" style="display:none;"></line></svg>

    <div id="ui-layer">
        <div id="mandala">
            <div id="sequencer">
                <div id="radar-container"></div>
                <div id="seq-sun" title="Tap to Cycle Sounds">KICK</div>
            </div>
        </div>

        <div id="voicing-control">
            <div class="v-label">High</div>
            <input type="range" orient="vertical" id="octave-slider" min="-2" max="2" step="1" value="0">
            <div class="v-label">Low</div>
        </div>

        <div id="controls-deck">
            <div class="deck-row">
                <div class="pad-btn" id="btn-arp">
                    ARP
                    <div class="opt-menu" id="arp-menu">
                        <div class="opt-item" data-pat="down">DOWN</div>
                        <div class="opt-item selected" data-pat="up">UP</div>
                        <div class="opt-item" data-pat="rand">RND</div>
                    </div>
                    <div class="locked-label">LOCKED</div>
                </div>
                <div class="pad-btn" id="btn-pulse">
                    PULSE
                    <div class="opt-menu" id="pulse-menu">
                        <div class="opt-item" data-pat="1/4">1/4</div>
                        <div class="opt-item selected" data-pat="1/8">1/8</div>
                        <div class="opt-item" data-pat="1/16">1/16</div>
                    </div>
                    <div class="locked-label">LOCKED</div>
                </div>
            </div>
            <div class="deck-row">
                <div class="inst-btn selected" data-type="pad"><div class="icon i-cir"></div></div>
                <div class="inst-btn" data-type="piano"><div class="icon i-tri"></div></div>
                <div class="inst-btn" data-type="lead"><div class="icon i-sq"></div></div>
            </div>
        </div>

        <div id="settings-toggle">âš™</div>
        <div id="settings-panel">
            <div class="setting-row"><label>Key</label><select id="root-select"></select></div>
            <div class="setting-row"><label>Scale</label><select id="scale-select"></select></div>
            <div class="setting-row"><label>Master Tuning</label><input type="range" id="tuning-range" min="432" max="448" value="440"><div id="tuning-val">440 Hz</div></div>
            
            <div class="setting-group">
                <label style="color: #ffcc00; margin-bottom: 10px; display:block;">Envelope (ADSR)</label>
                <div class="setting-row"><label>Attack</label><input type="range" id="adsr-a" min="0" max="2" step="0.01" value="0.4"></div>
                <div class="setting-row"><label>Decay</label><input type="range" id="adsr-d" min="0" max="2" step="0.01" value="0.3"></div>
                <div class="setting-row"><label>Sustain</label><input type="range" id="adsr-s" min="0" max="1" step="0.01" value="0.5"></div>
                <div class="setting-row"><label>Release (Sound)</label><input type="range" id="adsr-r" min="0.1" max="5" step="0.1" value="1.5"></div>
            </div>

            <div class="setting-group">
                <div class="setting-row">
                    <label>Modulation X (Slide Right)</label>
                    <select id="mod-x-select">
                        <option value="reverb" selected>Reverb</option>
                        <option value="filter">Filter</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Modulation Y (Slide Out)</label>
                    <select id="mod-y-select">
                        <option value="filter" selected>Filter</option>
                        <option value="reverb">Reverb</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
            
            <div class="check-group">
                <input type="checkbox" id="motion-check">
                <label for="motion-check" style="color:white; margin:0;">Ambient Motion (Blobs)</label>
            </div>
        </div>
    </div>

    <div id="splash-screen">
        <button class="ignite-btn" id="start-btn">IGNITE</button>
        <p style="margin-top:20px; color:#888; font-size:12px;">Turn up volume</p>
    </div>

    <script>
        /** THEORY */
        const Theory = {
            notes: ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'],
            scales: { major: [0,2,4,5,7,9,11], minor: [0,2,3,5,7,8,10], dorian: [0,2,3,5,7,9,10], lydian: [0,2,4,6,7,9,11], phrygian: [0,1,3,5,7,8,10] },
            colors: ['rgb(255, 60, 60)', 'rgb(255, 160, 60)', 'rgb(255, 220, 60)', 'rgb(80, 255, 100)', 'rgb(60, 200, 255)', 'rgb(100, 120, 255)', 'rgb(200, 80, 255)'],
            getFreq(note, octave, tuning=440) {
                const idx = this.notes.indexOf(note);
                const semitones = idx - 9 + (octave - 4) * 12;
                return tuning * Math.pow(2, semitones / 12);
            },
            getScale(root, scaleName) {
                const rootIdx = this.notes.indexOf(root);
                return this.scales[scaleName].map(interval => this.notes[(rootIdx + interval) % 12]);
            },
            getChord(scaleNotes, degree, rootOctave=3, tuning=440) {
                const indices = [degree, (degree+2)%7, (degree+4)%7, (degree+6)%7];
                const notes = indices.map((idx, pos) => {
                    let n = scaleNotes[idx];
                    let o = rootOctave;
                    if(pos === 0) { if(this.notes.indexOf(n) >= 7) o = 2; else o = 3; } 
                    else { o = 4; if(idx < degree) o++; }
                    return { note: n, freq: this.getFreq(n, o, tuning), octave: o }; 
                });
                return { notes, name: notes[0].note, degree };
            }
        };

        /** AUDIO */
        class AudioEngine {
            constructor() {
                this.ctx = null; this.master = null; this.inst = 'pad';
                this.activeVoices = new Map();
                this.params = { attack: 0.4, decay: 0.3, sustain: 0.5, release: 1.5, detune: 3, cutoff: 3000, waveform: 'triangle', tuning: 440 };
            }
            init() {
                try {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AC();
                    this.master = this.ctx.createGain(); this.master.gain.value = 0.4;
                    this.compressor = this.ctx.createDynamicsCompressor(); this.compressor.threshold.value = -15;
                    this.verb = this.ctx.createConvolver(); this.createReverb();
                    this.master.connect(this.compressor); this.compressor.connect(this.ctx.destination);
                    this.master.connect(this.verb); this.verb.connect(this.ctx.destination);
                    return true;
                } catch(e) { console.error(e); return false; }
            }
            createReverb() {
                const len = this.ctx.sampleRate * 2.5; const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for(let i=0; i<len; i++) {
                    const decay = Math.pow(1 - i/len, 2);
                    buf.getChannelData(0)[i] = (Math.random()*2-1)*decay * 0.5;
                    buf.getChannelData(1)[i] = (Math.random()*2-1)*decay * 0.5;
                }
                this.verb.buffer = buf;
            }
            modulateChord(id, x, y) {
                if(!this.ctx || !this.activeVoices.has(id)) return;
                const voices = this.activeVoices.get(id);
                const apply = (type, val) => {
                    if(type === 'filter') {
                        const mult = Math.max(0.2, Math.min(4.0, 1 + (val * 0.02))); 
                        voices.forEach(v => { if(v.filter) v.filter.frequency.setTargetAtTime(v.baseFreq * mult, this.ctx.currentTime, 0.1); });
                    }
                    if(type === 'reverb') {
                        const gain = Math.max(0, Math.min(1, val * 0.005)); 
                        voices.forEach(v => { if(v.wetGain) v.wetGain.gain.setTargetAtTime(gain, this.ctx.currentTime, 0.1); });
                    }
                };
                apply(APP.modX, x); apply(APP.modY, y); 
            }
            playChord(chord, id, modX=0, modY=0) {
                if(!this.ctx) return;
                this.stopChord(id);
                const voices = [];
                const octaveShift = APP.octave * 12; 
                const freqMult = Math.pow(2, octaveShift/12);
                
                chord.notes.forEach((n, i) => { 
                    const finalFreq = n.freq * freqMult;
                    const v = this.createVoice(finalFreq, this.ctx.currentTime + i*0.01);
                    voices.push(v); 
                });
                this.activeVoices.set(id, voices);
                this.modulateChord(id, modX, modY); 
            }
            stopChord(id) {
                if(!this.ctx) return;
                if(this.activeVoices.has(id)) {
                    const now = this.ctx.currentTime;
                    const rel = parseFloat(this.params.release);
                    this.activeVoices.get(id).forEach(v => {
                        v.gain.gain.cancelScheduledValues(now);
                        v.gain.gain.setValueAtTime(v.gain.gain.value, now);
                        v.gain.gain.linearRampToValueAtTime(0, now + rel);
                        v.osc.stop(now + rel + 0.1);
                    });
                    this.activeVoices.delete(id);
                }
            }
            createVoice(freq, startTime) {
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); const filter = this.ctx.createBiquadFilter();
                const wetGain = this.ctx.createGain(); wetGain.gain.value = 0; 
                
                const a = parseFloat(this.params.attack);
                const d = parseFloat(this.params.decay);
                const s = parseFloat(this.params.sustain);
                
                if(this.inst === 'pad') {
                    osc.type = 'triangle'; filter.type = 'lowpass'; filter.frequency.value = 800; filter.Q.value = 0.5;
                    gain.gain.setValueAtTime(0, startTime); 
                    gain.gain.linearRampToValueAtTime(0.15, startTime + a); 
                    gain.gain.setTargetAtTime(0.15 * s, startTime + a, d);
                } else if (this.inst === 'piano') {
                    osc.type = 'triangle'; filter.type = 'lowpass'; filter.frequency.value = 3000;
                    gain.gain.setValueAtTime(0, startTime); 
                    gain.gain.linearRampToValueAtTime(0.3, startTime + a); 
                    gain.gain.setTargetAtTime(0.3 * s, startTime + a, d);
                } else { 
                    osc.type = 'sawtooth'; filter.type = 'lowpass'; filter.frequency.value = 2000; filter.Q.value = 2;
                    gain.gain.setValueAtTime(0, startTime); 
                    gain.gain.linearRampToValueAtTime(0.1, startTime + a); 
                    gain.gain.setTargetAtTime(0.1 * s, startTime + a, d);
                }
                osc.frequency.value = freq; osc.connect(filter); filter.connect(gain); gain.connect(this.master);
                filter.connect(wetGain); wetGain.connect(this.verb); osc.start(startTime);
                return { osc, gain, filter, wetGain, baseFreq: filter.frequency.value };
            }
            playOneShot(freq, time, dur, modX=0, modY=0) {
                // For Sequencer / Arp: Tight Pluck Sound
                const osc = this.ctx.createOscillator(); 
                // Use pluckier wave for seq
                osc.type = this.inst === 'pad' ? 'triangle' : 'sawtooth';
                osc.frequency.value = freq;
                
                const g = this.ctx.createGain(); 
                const f = this.ctx.createBiquadFilter();
                
                // Tighter filter for sequence
                f.type = 'lowpass'; 
                f.frequency.value = 1500; // Bright pluck
                
                // Wet/Dry Reverb still applies
                const wet = this.ctx.createGain();
                wet.gain.value = 0.1; // Default some verb

                osc.connect(f); f.connect(g); g.connect(this.master);
                f.connect(wet); wet.connect(this.verb);

                // Fast Envelope
                g.gain.setValueAtTime(0, time); 
                g.gain.linearRampToValueAtTime(0.3, time + 0.01); 
                g.gain.exponentialRampToValueAtTime(0.001, time + dur);
                
                osc.start(time); osc.stop(time + dur);
            }
            playKick() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                g.gain.setValueAtTime(1, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                osc.connect(g); g.connect(this.master); osc.start(t); osc.stop(t + 0.5);
            }
            playSnare() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const noise = this.ctx.createBufferSource();
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for(let i=0; i<data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buf;
                const f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1000;
                const g = this.ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                noise.connect(f); f.connect(g); g.connect(this.master);
                noise.start(t);
            }
        }

        /** VISUALS */
        class Visuals {
            constructor() {
                this.canvas = document.getElementById('main-canvas'); this.ctx = this.canvas.getContext('2d');
                this.sunElement = document.getElementById('seq-sun'); 
                this.blobs = []; this.clouds = []; this.sustains = new Map(); 
                for(let i=0; i<6; i++) {
                    this.blobs.push({
                        x: Math.random(), y: Math.random(),
                        r: 200 + Math.random() * 200,
                        dx: (Math.random()-0.5)*0.001, dy: (Math.random()-0.5)*0.001,
                        color: {r:10, g:10, b:20}
                    });
                }
            }
            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr; 
                this.canvas.height = window.innerHeight * dpr; 
                this.ctx.scale(dpr, dpr);
            }
            
            sustainOn(id, colorStr) {
                let s = this.sustains.get(id);
                if (!s) {
                    let c = {r:255,g:255,b:255};
                    const m = colorStr.match(/\d+/g);
                    if(m) c = {r: parseInt(m[0]), g: parseInt(m[1]), b: parseInt(m[2])};
                    
                    s = {
                        color: c,
                        alpha: 0,
                        targetAlpha: 0.8, 
                        r: 50,
                        maxR: Math.max(window.innerWidth, window.innerHeight) * 1.2,
                        decaying: false
                    };
                    this.sustains.set(id, s);
                } else {
                    s.targetAlpha = 0.8;
                    s.decaying = false;
                }
            }

            sustainOff(id) {
                let s = this.sustains.get(id);
                if(s) {
                    s.decaying = true;
                }
            }

            trigger(colorStr, isKick=false) {
                const w = window.innerWidth; const h = window.innerHeight;
                let cx = w/2; let cy = h/2;
                if(this.sunElement) {
                    const rect = this.sunElement.getBoundingClientRect();
                    cx = rect.left + rect.width/2; cy = rect.top + rect.height/2;
                }

                if(isKick) {
                    this.clouds.push({type:'kick', r: 30, maxR: Math.max(w,h)*0.5, alpha: 0.1, x:cx, y:cy, color: '255,255,255'});
                } else {
                    let c = '255,255,255';
                    if(colorStr.startsWith('rgb')) c = colorStr.match(/\d+,\s*\d+,\s*\d+/)[0];
                    this.clouds.push({type:'chord', r: 10, maxR: Math.max(w,h)*1.2, alpha: 0.6, x:cx, y:cy, color: c});
                }
            }

            loop() {
                requestAnimationFrame(this.loop.bind(this));
                const w = window.innerWidth; const h = window.innerHeight;
                
                let cx = w/2; let cy = h/2;
                if(this.sunElement) {
                    const rect = this.sunElement.getBoundingClientRect();
                    cx = rect.left + rect.width/2; cy = rect.top + rect.height/2;
                }
                
                this.ctx.fillStyle = '#000'; 
                this.ctx.fillRect(0,0,w,h);

                if(APP.enableBlobs) {
                    this.ctx.globalCompositeOperation = 'screen';
                    this.blobs.forEach(b => {
                        b.x += b.dx; b.y += b.dy;
                        if(b.x<0||b.x>1) b.dx*=-1; if(b.y<0||b.y>1) b.dy*=-1;
                        const x = b.x*w; const y = b.y*h;
                        const g = this.ctx.createRadialGradient(x, y, 0, x, y, b.r);
                        g.addColorStop(0, `rgba(${b.color.r},${b.color.g},${b.color.b}, 0.2)`);
                        g.addColorStop(1, `rgba(${b.color.r},${b.color.g},${b.color.b}, 0)`);
                        this.ctx.fillStyle = g; this.ctx.beginPath(); this.ctx.arc(x, y, b.r, 0, Math.PI*2); this.ctx.fill();
                    });
                }

                this.ctx.globalCompositeOperation = 'screen';
                this.sustains.forEach((s, id) => {
                    if(s.decaying) {
                        s.alpha -= 0.0026; 
                        if(s.alpha < 0) s.alpha = 0;
                    } else {
                        s.alpha += (s.targetAlpha - s.alpha) * 0.1;
                    }
                    const time = Date.now() * 0.001; const breathe = Math.sin(time + id) * 50; 
                    const currentR = Math.min(s.maxR, s.r + (s.alpha * s.maxR * 0.8) + breathe);
                    const g = this.ctx.createRadialGradient(cx, cy, 0, cx, cy, currentR);
                    g.addColorStop(0, `rgba(${s.color.r},${s.color.g},${s.color.b}, ${s.alpha * 1.2})`);
                    g.addColorStop(0.3, `rgba(${s.color.r},${s.color.g},${s.color.b}, ${s.alpha * 0.6})`);
                    g.addColorStop(1, `rgba(${s.color.r},${s.color.g},${s.color.b}, 0)`);
                    this.ctx.fillStyle = g;
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, currentR, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    if(s.decaying && s.alpha <= 0) {
                        this.sustains.delete(id);
                    }
                });

                for(let i=this.clouds.length-1; i>=0; i--) {
                    let p = this.clouds[i];
                    p.r += p.type === 'kick' ? 2 : 3; 
                    p.alpha -= p.type === 'kick' ? 0.001 : 0.003; 

                    if(p.alpha <= 0) {
                        this.clouds.splice(i, 1);
                    } else {
                        const g = this.ctx.createRadialGradient(cx, cy, p.r * 0.2, cx, cy, p.r);
                        g.addColorStop(0, `rgba(${p.color}, 0)`); 
                        g.addColorStop(0.8, `rgba(${p.color}, ${p.alpha})`); 
                        g.addColorStop(1, `rgba(${p.color}, 0)`); 

                        this.ctx.fillStyle = g;
                        this.ctx.beginPath();
                        this.ctx.arc(cx, cy, p.r, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.globalCompositeOperation = 'source-over';
            }
        }

        /** APP LOGIC */
        const APP = { 
            root: 'C', scale: 'major', tuning: 440, inst: 'pad', bpm: 120, octave: 0,
            activeChords: new Set(), performanceMode: null, arpLocked: false, arpPattern: 'up',
            pulseLocked: false, pulsePattern: '1/8',
            modX: 'reverb', modY: 'filter', enableBlobs: false,
            seqMode: 'kick', uploadedChord: null, seqColor: 'rgb(255,255,255)'
        };
        const Audio = new AudioEngine(); const Vis = new Visuals();
        const Sequencer = { steps: Array(8).fill(false), pos: 0 };

        window.onload = () => {
            Vis.resize(); Vis.loop(); window.addEventListener('resize', () => Vis.resize());
            initUI(); startClock(); setupKeyboard();
        };

        document.getElementById('start-btn').onclick = () => {
            Audio.init(); if(Audio.ctx) Audio.ctx.resume();
            document.getElementById('splash-screen').classList.add('hidden');
        };

        function setupKeyboard() {
            const keyMap = {'1':0, '2':1, '3':2, '4':3, '5':4, '6':5, '7':6};
            window.addEventListener('keydown', e => {
                if(keyMap.hasOwnProperty(e.key)) {
                    const idx = keyMap[e.key];
                    const btn = document.querySelector(`.chord-orb[data-id="${idx}"]`);
                    if(btn && !btn.classList.contains('active')) {
                         btn._activate({ 
                             preventDefault: ()=>{}, stopPropagation: ()=>{},
                             clientX: btn.getBoundingClientRect().left + btn.offsetWidth/2,
                             clientY: btn.getBoundingClientRect().top + btn.offsetHeight/2
                         });
                    }
                }
            });
            window.addEventListener('keyup', e => {
                if(keyMap.hasOwnProperty(e.key)) {
                    const idx = keyMap[e.key];
                    const btn = document.querySelector(`.chord-orb[data-id="${idx}"]`);
                    if(btn) { btn._deactivate({ preventDefault: ()=>{}, stopPropagation: ()=>{} }); }
                }
            });
        }

        function initUI() {
            const rSel = document.getElementById('root-select'); Theory.notes.forEach(n => rSel.add(new Option(n, n)));
            rSel.onchange = e => { APP.root = e.target.value; renderMandala(); };
            const sSel = document.getElementById('scale-select'); Object.keys(Theory.scales).forEach(k => sSel.add(new Option(k, k)));
            sSel.onchange = e => { APP.scale = e.target.value; renderMandala(); };
            document.getElementById('tuning-range').oninput = e => { APP.tuning = parseInt(e.target.value); document.getElementById('tuning-val').innerText = APP.tuning + ' Hz'; renderMandala(); };
            document.getElementById('settings-toggle').onclick = () => document.getElementById('settings-panel').classList.toggle('open');
            document.getElementById('octave-slider').oninput = e => { APP.octave = parseInt(e.target.value); renderMandala(); };
            document.querySelectorAll('.inst-btn').forEach(btn => {
                btn.onclick = () => { 
                    document.querySelectorAll('.inst-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); Audio.inst = btn.dataset.type; 
                    updateADSRUI(Audio.inst);
                };
            });
            
            document.getElementById('mod-x-select').onchange = e => APP.modX = e.target.value;
            document.getElementById('mod-y-select').onchange = e => APP.modY = e.target.value;
            document.getElementById('motion-check').onchange = e => APP.enableBlobs = e.target.checked;

            // ADSR UI
            const adsr = ['a','d','s','r'];
            adsr.forEach(k => {
                const el = document.getElementById('adsr-'+k);
                el.oninput = () => {
                    const map = {a:'attack',d:'decay',s:'sustain',r:'release'};
                    Audio.params[map[k]] = parseFloat(el.value);
                };
            });
            function updateADSRUI(inst) {
                let p = {a:0.4,d:0.3,s:0.5,r:1.5};
                if(inst === 'piano') p = {a:0.01,d:0.3,s:0.05,r:0.5};
                if(inst === 'lead') p = {a:0.05,d:0.1,s:0.5,r:0.2};
                Audio.params = {...Audio.params, attack:p.a, decay:p.d, sustain:p.s, release:p.r};
                document.getElementById('adsr-a').value = p.a;
                document.getElementById('adsr-d').value = p.d;
                document.getElementById('adsr-s').value = p.s;
                document.getElementById('adsr-r').value = p.r;
            }

            // PERFORMANCE PADS
            const handlePad = (id, mode) => {
                const btn = document.getElementById(id);
                let startY = 0; let touched = false;
                let hoveredOption = null;

                const onMove = (e) => {
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;

                    // Menu Logic (Slide Up)
                    const el = document.elementFromPoint(clientX, clientY);
                    if(el && el.classList.contains('opt-item')) {
                         const parent = el.parentElement;
                         parent.querySelectorAll('.opt-item').forEach(o => o.classList.remove('selected'));
                         el.classList.add('selected');
                         hoveredOption = el;
                    } else {
                        hoveredOption = null;
                    }
                };

                const onEnd = (e) => {
                    window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd);
                    window.removeEventListener('touchmove', onMove); window.removeEventListener('touchend', onEnd);

                    btn.classList.remove('menu-open'); 
                    
                    // LOCK LOGIC
                    if (hoveredOption) {
                        const pat = hoveredOption.dataset.pat;
                        if (mode === 'arp') {
                            APP.arpLocked = true;
                            APP.arpPattern = pat;
                        } else {
                            APP.pulseLocked = true;
                            APP.pulsePattern = pat;
                        }
                        btn.classList.add('locked');
                        APP.performanceMode = mode;
                        return;
                    }
                    
                    const isLocked = (mode === 'arp' ? APP.arpLocked : APP.pulseLocked);
                    
                    if (!isLocked) {
                        APP.performanceMode = null; 
                        btn.classList.remove('active');
                        APP.activeChords.forEach(item => Audio.playChord(item.chord, item.id, item.modX, item.modY));
                    }
                };

                const onStart = (e) => {
                    if(e.type === 'mousedown' && touched) return;
                    if(e.type === 'touchstart') touched = true;
                    e.preventDefault(); e.stopPropagation();

                    // Unlock
                    const isLocked = (mode === 'arp' ? APP.arpLocked : APP.pulseLocked);
                    if(isLocked) {
                         if(mode === 'arp') APP.arpLocked = false; else APP.pulseLocked = false;
                         btn.classList.remove('locked'); 
                         btn.classList.remove('active');
                         APP.performanceMode = null;
                         APP.activeChords.forEach(item => Audio.playChord(item.chord, item.id, item.modX, item.modY));
                         return; 
                    }

                    // Normal Start
                    startY = e.touches ? e.touches[0].clientY : e.clientY;
                    window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd);
                    window.addEventListener('touchmove', onMove, {passive: false}); window.addEventListener('touchend', onEnd);

                    btn.classList.add('menu-open'); 
                    btn.classList.add('active');
                    APP.performanceMode = mode;
                    APP.activeChords.forEach(item => Audio.stopChord(item.id));
                };

                btn.addEventListener('mousedown', onStart); btn.addEventListener('touchstart', onStart);
            };

            handlePad('btn-arp', 'arp');
            handlePad('btn-pulse', 'pulse');

            renderMandala(); renderSequencer();
        }

        function renderMandala() {
            const container = document.getElementById('mandala');
            const old = document.querySelectorAll('.chord-orb, .pivot-group'); old.forEach(el => el.remove());
            const scaleNotes = Theory.getScale(APP.root, APP.scale);
            const roman = ['I','II','III','IV','V','VI','VII'];

            for(let i=0; i<7; i++) {
                const chord = Theory.getChord(scaleNotes, i, 3, APP.tuning);
                const angle = (i / 7) * Math.PI * 2 - (Math.PI/2);
                const x = 50 + Math.cos(angle) * 40; const y = 50 + Math.sin(angle) * 40;
                const orb = document.createElement('div');
                orb.className = 'chord-orb'; orb.style.left = x + '%'; orb.style.top = y + '%';
                orb.style.setProperty('--glow', Theory.colors[i]);
                orb.innerHTML = `<div class="roman">${roman[i]}</div><div class="note-name">${chord.name}</div>`;
                orb.dataset.id = i;

                let startY = 0; let startX = 0; let active = false;
                const id = `chord-${i}`;

                const start = (e) => {
                    if(e.preventDefault) e.preventDefault();
                    if(e.touches && e.touches.length > 1) return; 
                    active = true;
                    startY = e.touches ? e.touches[0].clientY : (e.clientY || 0);
                    startX = e.touches ? e.touches[0].clientX : (e.clientX || 0);
                    
                    orb.classList.add('active');
                    const item = {id, chord, index: i, modX: 0, modY: 0};
                    APP.activeChords.add(item); 
                    Vis.trigger(Theory.colors[i]); Vis.sustainOn(i, Theory.colors[i]); 
                    showPivots(x, y, chord.name);
                    
                    // SOLAR INJECTION LOGIC (Start)
                    orb.classList.add('dragging');

                    const anyPerf = APP.performanceMode || APP.arpLocked || APP.pulseLocked;
                    if(!anyPerf) { Audio.playChord(chord, id); }
                };
                
                orb._activate = start;

                const move = (e) => {
                    if(!active) return;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    
                    // SIMPLE XY
                    const dy = Math.max(-100, Math.min(100, cy - startY));
                    const dx = Math.max(-100, Math.min(100, cx - startX));
                    
                    // SOLAR INJECTION LOGIC (Check distance to sun)
                    // Get Center
                    const w = window.innerWidth; const h = window.innerHeight;
                    const distToCenter = Math.hypot(cx - w/2, cy - h/2);
                    const sun = document.getElementById('seq-sun');
                    
                    if(distToCenter < 80) {
                        // Hovering Sun
                        sun.style.background = Theory.colors[i];
                        sun.style.transform = 'scale(1.2)';
                    } else {
                        sun.style.background = '';
                        sun.style.transform = '';
                    }
                    
                    // If NOT injecting, do normal mod
                    if(distToCenter > 80) {
                        const scale = 0.95 + (dy * 0.001);
                        orb.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px) scale(${scale})`;
                        // Audio Mod: Up is negative dy in pixel space, but we want UP to open filter
                        // UP = -dy. 
                        Audio.modulateChord(id, dx, -dy);
                        APP.activeChords.forEach(it => { if(it.id === id) { it.modX = dx; it.modY = -dy; } });
                    } else {
                        // Allow full drag to center
                        orb.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    }
                };

                const end = (e) => {
                    if(e && e.preventDefault) e.preventDefault();
                    active = false; orb.classList.remove('active');
                    orb.style.transform = 'translate(-50%, -50%)';
                    orb.classList.remove('dragging');

                    // SOLAR INJECTION DROP
                    const w = window.innerWidth; const h = window.innerHeight;
                    const cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                    const cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                    const distToCenter = Math.hypot(cx - w/2, cy - h/2);
                    
                    if(distToCenter < 80) {
                        // UPLOAD!
                        APP.uploadedChord = chord;
                        APP.seqMode = 'chord';
                        APP.seqColor = Theory.colors[i];
                        updateSunVisuals();
                        // Flash effect
                        const sun = document.getElementById('seq-sun');
                        sun.style.boxShadow = `0 0 100px ${APP.seqColor}`;
                        setTimeout(()=> sun.style.boxShadow = '', 500);
                    }
                    
                    const sun = document.getElementById('seq-sun');
                    sun.style.transform = ''; sun.style.background = '';

                    Vis.sustainOff(i); Audio.stopChord(id);
                    APP.activeChords.forEach(item => { if(item.id === id) APP.activeChords.delete(item); });
                };
                
                orb._deactivate = end;

                orb.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
                orb.addEventListener('touchstart', start); window.addEventListener('touchmove', move); window.addEventListener('touchend', end);
                container.appendChild(orb);
            }
        }
        
        function updateSunVisuals() {
            const sun = document.getElementById('seq-sun');
            if(APP.seqMode === 'kick') {
                sun.innerText = "KICK";
                sun.style.borderColor = "rgba(255,255,255,0.5)";
                sun.style.color = "white";
            } else if (APP.seqMode === 'chord') {
                sun.innerText = APP.uploadedChord.name;
                sun.style.borderColor = APP.seqColor;
                sun.style.color = APP.seqColor;
            } else {
                sun.innerText = "PERC";
                sun.style.borderColor = "cyan";
                sun.style.color = "cyan";
            }
        }

        function startClock() {
            let sixteenthCounter = 0;
            const loop = () => {
                requestAnimationFrame(loop);
                if(!Audio.ctx) return;
                const time = Audio.ctx.currentTime;
                const beatDur = 60 / APP.bpm;
                const stepDur = beatDur / 2; const sixteenthDur = beatDur / 4; const cycle = stepDur * 8; const progress = (time % cycle) / cycle;
                const currentStep = Math.floor(progress * 8);
                if(currentStep !== Sequencer.pos) {
                    Sequencer.pos = currentStep;
                    if(Sequencer.steps[currentStep]) {
                        // SEQ PLAY LOGIC
                        if(APP.seqMode === 'kick') {
                            Audio.playKick(); Vis.trigger('rgb(255,255,255)', true);
                        } else if (APP.seqMode === 'chord' && APP.uploadedChord) {
                            // Play tight chord stab
                            // Auto tighten ADSR logic is in playOneShot
                            const freqMult = Math.pow(2, (APP.octave*12)/12);
                            APP.uploadedChord.notes.forEach(n => Audio.playOneShot(n.freq * freqMult, time, 0.2)); // Short
                            Vis.trigger(APP.seqColor, true);
                        } else {
                            Audio.playSnare(); Vis.trigger('rgb(0,255,255)', true);
                        }

                        const p = document.getElementById('planet-'+currentStep);
                        p.classList.add('trigger'); setTimeout(() => p.classList.remove('trigger'), 100);
                    }
                    if(APP.performanceMode === 'pulse' && APP.activeChords.size > 0) {
                        const octaveShift = APP.octave * 12; const freqMult = Math.pow(2, octaveShift/12);
                        APP.activeChords.forEach(item => {
                            item.chord.notes.forEach(n => Audio.playOneShot(n.freq * freqMult, time, 0.2, item.modX, item.modY));
                            Vis.trigger(Theory.colors[item.index]);
                        });
                    }
                }
                const current16th = Math.floor(time / sixteenthDur);
                if(current16th !== sixteenthCounter) {
                    sixteenthCounter = current16th;
                    if((APP.performanceMode === 'arp' || APP.arpLocked) && APP.activeChords.size > 0) {
                        const octaveShift = APP.octave * 12; const freqMult = Math.pow(2, octaveShift/12);
                        APP.activeChords.forEach(item => {
                            const noteIndex = current16th % item.chord.notes.length;
                            const note = item.chord.notes[noteIndex];
                            Audio.playOneShot(note.freq * freqMult, time, 0.15, item.modX, item.modY);
                            Vis.trigger(Theory.colors[item.index]);
                        });
                    }
                    if((APP.performanceMode === 'pulse' || APP.pulseLocked) && APP.activeChords.size > 0) {
                         let trigger = false;
                         if (APP.pulsePattern === '1/16') trigger = true;
                         else if (APP.pulsePattern === '1/8' && current16th % 2 === 0) trigger = true;
                         else if (APP.pulsePattern === '1/4' && current16th % 4 === 0) trigger = true;
                         if (trigger) {
                             const octaveShift = APP.octave * 12; const freqMult = Math.pow(2, octaveShift/12);
                             APP.activeChords.forEach(item => {
                                 item.chord.notes.forEach(n => Audio.playOneShot(n.freq * freqMult, time, 0.2, item.modX, item.modY));
                                 Vis.trigger(Theory.colors[item.index]);
                             });
                         }
                    }
                }
            };
            loop();
        }

        function renderSequencer() {
            const container = document.getElementById('sequencer'); const sun = document.getElementById('seq-sun');
            const planets = [];
            for(let i=0; i<8; i++) {
                const p = document.createElement('div'); p.className = 'planet'; p.id = 'planet-'+i;
                const a = (i/8)*Math.PI*2 - Math.PI/2;
                p.style.left = (50 + Math.cos(a)*45) + '%'; p.style.top = (50 + Math.sin(a)*45) + '%';
                const toggle = (e) => { e.stopPropagation(); Sequencer.steps[i] = !Sequencer.steps[i]; p.classList.toggle('active'); };
                p.addEventListener('mousedown', toggle); p.addEventListener('touchstart', toggle);
                container.appendChild(p); planets.push(p);
            }
            
            // SUN CYCLER
            const cycle = (e) => { 
                e.stopPropagation(); e.preventDefault(); 
                if (APP.seqMode === 'kick') {
                    if(APP.uploadedChord) APP.seqMode = 'chord'; else APP.seqMode = 'perc';
                } else if (APP.seqMode === 'chord') {
                    APP.seqMode = 'perc';
                } else {
                    APP.seqMode = 'kick';
                }
                updateSunVisuals();
            };
            sun.addEventListener('mousedown', cycle);
            sun.addEventListener('touchstart', cycle);
        }

        function showPivots(cx, cy, root) {
            document.querySelectorAll('.pivot-group').forEach(el=>el.remove());
            const group = document.createElement('div'); group.className = 'pivot-group';
            const dx = (cx - 50) * 1.4; const dy = (cy - 50) * 1.4;
            group.style.left = (50+dx) + '%'; group.style.top = (50+dy) + '%';
            ['Maj', 'Min'].forEach(mode => {
                const btn = document.createElement('div'); btn.className = 'pivot-btn'; btn.innerText = mode;
                const click = (e) => {
                    e.stopPropagation(); APP.root = root; APP.scale = mode === 'Maj' ? 'major' : 'minor';
                    document.getElementById('root-select').value = root; document.getElementById('scale-select').value = APP.scale;
                    renderMandala();
                };
                btn.addEventListener('mousedown', click); btn.addEventListener('touchstart', click);
                group.appendChild(btn);
            });
            document.getElementById('mandala').appendChild(group);
        }
    </script>
</body>
</html>
